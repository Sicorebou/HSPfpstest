/*追加するもの
・武器切り替え
・銃口フラッシュ
・敵移動
・dmmpan命令で音の臨場感
*/

#include "hgimg3.as" ;ライブラリインクルード

screenx=320 : screeny=180
screen 0,screenx,screeny


hgini ;hg開始
dmmini ;サウンドのアレ

;フォント
setfont 16,16,12,1	; font Tex select(cx,cy,px,mode)
texload "fontchr.bmp"	; フォントテクスチャの登録

setborder 1024,24,1024
;---------------各初期値

;初期値 前後移動量
angles=0.02 : movef=5.0 : moveb=3.0 : movesi=2.0

;ジャンプ用の値など
grlvl=-6.0 : g=9.8 : vo=5.0 : jumph=20.0

;足音再生レート
a=movef/moveb
b=movef/movesi
stepc=12 : steprf=23 : steprb=steprf*a : steprsi=steprf*b
hp=100

;弾移動量保存用
bulx=0 : bulz=0 : buldam=30  : shotcnt=0

;敵ステータス
ehp=150 : enemx=32 : ecounter=0 : hpbarx=8 : hpbary=2 : encnt=enemx
dim enhp,enemx

;視点感度
sens=0.001

;`ヒット判定用
hitc=0

;壁サイズ
boxsize=32 : mapw=1024 : maph=1024 
;addmesh

;プレイヤー初期位置
defx=500 : defz=-50
selcang : objset1r 1,0
selcpos : objset3 defx,grlvl,defz

;テスト用
;name=0
;---------------

;	SKY:青空
	;
;clstex 5
	/*addxfile m_sky,"skybox.x"
	modelshade m_sky,0
	regobj sky, m_sky
	setscale sky,30,10,30
	setpos sky,0,grlvl-boxsize*2,0
	setefx sky,$500			; Zバッファを更新しない
	objproj sky,1			; 通常のZクリップを無効にする

	setdir HGOBJ_LIGHT,100,100,100
	setang HGOBJ_LIGHT, -1.0, -1.0, 0.0*/

;---------------モデル読み込み
addxfile mdwp1,"DE.x"　;武器モデル読み込み
addxfile mdwp2,"Rifle.x"

regobj obwp1,mdwp1
setscale obwp1,0.7,0.7,0.7

regobj obwp2,mdwp2

addplate mdhp,1,hpbarx,hpbary,0,79,79,4
addxfile mden,"body.x"　;敵(仮)モデル読み込み
repeat enemx
	c=cnt
	enhp(c)=ehp
	rex=rnd(32) : rez=rnd(32)
	ex=32*rex-496 : ez=32*rez-496
	regobj oben(c),mden
	;regobj obhp(c),mdhp,OBJ_XFRONT
	setcoli oben(c),1,2
	setscale oben(c),10.0,10.0,10.0
	selpos oben(c) : objset3 ex,grlvl,ez
	;selpos obhp(c) : objset3 ex,grlvl-30,ez
	loop

sdim a,1122
bload "map2.txt",a　;マップデータ読み込み
notesel a ;デフォ作業

;障害物生成
addbox mdbx,boxsize,boxsize,2

z=0 ;z行目x番目を取得
x=0

repeat notemax
noteget b,z ;b←z行目の文字列が代入される
 repeat notesize/notemax ;全体の文字数/行数=x方向に並ぶ文字数
 x=cnt
 s=strmid(b,x,1)
 switch s
case 1
	regobj obbx,mdbx,OBJ_STATIC
	setcoli obbx,4,2
	bx=boxsize*x-(mapw/2-boxsize/2) : bz=boxsize*z-(maph/2-boxsize/2)
	setscale obbx,1.0,10.0,1.0
	selpos obbx : objset3 bx,grlvl,bz
 swbreak
 ;1よりデカいときはブロックをn個分積み重ねる
 default
  repeat int(s)
	regobj obbx,mdbx,OBJ_STATIC
	setcoli obbx,4
	bx=boxsize*x-(mapw/2-boxsize/2) : bz=boxsize*z-(maph/2-boxsize/2)
	selpos obbx : objset3 bx,grlvl-cnt*boxsize,bz
  loop
swend
 loop
 z+=1
loop

;床のモデル作成
addmesh mdpl,32,32,16,1024,1024,2

;弾モデル作成
addplate mdsh,1,4,4,1,800,800,stat

;床描画
regobj obpl,mdpl,OBJ_GROUND
selpos obpl : objset3 0,0,0

;プレイヤー位置用箱描画
addbox mplayer,16,16
regobj oplayer,mplayer

;クロスヘア用
addspr mdcr,1,0,0,
;---------------

;---------------各種データ読み込み
mmload "ambience.wav",0,1

dmmload "stepf.wav",0,0 ;mmloadは違うサウンドが流れているとそのサウンドを止めて再生するので途切れる
dmmload "stepb.wav",1,0　
dmmload "rust_rev.wav",2,0 
dmmload "headshot_0.wav",3,0
dmmload "de_sound.wav",4,0
dmmload "hit.wav",5,0
dmmload "zombie_die.wav",6,0
dmmload "aim_0.wav",7,0
dmmload "buffaug-1.wav",8,0
dmmload "beam.wav",9,0

texload "xyz.jpg"　;テクスチャ
texload2 "wall_0.png"
texload2 "brick_0.png"
texload2 "crosshair.png"
texload2 "shoti.png",stat
texload "sky.jpg"
pos 10,10
;picload "xyz.jpg",1

*start ;スタート画面

;clstex
pos screenx/2,screeny/2 

button goto "スタート",*clear
stop

*clear ;スタート画面消去
	cls
	mmplay 0 ;BGM開始
	;layerobj 128,128,objlayer_normal,*crossh,100
	goto *main

;----------------------------------------------------------------------------------------------------------------------------------MAIN
*main

	getkey pri,49 ;1 
	getkey sec,50 ;2
	
	if pri=1 : kycheck=10
	if sec=1 : kycheck=20
	
	getkey w,87
	getkey a,65
	getkey s,83
	getkey d,68
	getkey space,32 
	getkey esc,27
	
	getkey r,39 ;カーソル
	getkey l,37

	getkey ml,1
	getkey mr,2 ;右クリ

	getkey mai,48
	getkey sub,49 ;武器

	stick ky,0 ;adsサウンド用

;---------------プレイヤー視点処理
	gosub *viewp
;---------------

;---------------プレイヤー位置処理

	selcpos : objgetfv po
	dx=sin(an(1)/3.14*M_PI) ;視点角度から移動量計算
	dz=cos(an(1)/3.14*M_PI)
	dy=sin(an(0)/3.14*M_PI)

	gosub *plmove
	
	gosub *wallhit
;--------------プレイヤー位置終了


;--------------武器モデルの処理
	selang obwp1 : objgetfv wpan
	
	wdy=sin(an(0)/3.14*M_PI)
	wpy=po(1)-wpdist*wdy
	
	if mr=1{ ;右クリされてたらADS動作
	wdx=sin(an(1)/3.14*M_PI) ;視点角度から移動量計算
	wdz=cos(an(1)/3.14*M_PI)
	wpy+=1.0
	if ky&512 : dmmplay 7
}else{
	wan=an(1)-(M_PI*1/10) ;視点角度よりも少しだけ右寄りに(180/8度だけ)配置
	wdx=sin(wan/3.14*M_PI) ;視点角度から移動量計算
	wdz=cos(wan/3.14*M_PI)
	wpy+=2
}
	
	wpdist=10.0
	wpx=po(0)-wpdist*wdx
	wpz=po(2)-wpdist*wdz  ;プレイヤー座標より前に配置

	selpos obwp1 : objsetf3 wpx,wpy,wpz

	;キーによる武器回転
	;if r=1 : wpan(0)-=angles
	;if l=1 : wpan(0)+=angles

	;selang obwp1 : objsetfv wpan
	selang obwp1 : objsetfv an

;--------------処理終了

/*コリジョン値
1:敵
2:弾
4:壁
*/
;--------------撃
    shots=2 ;弾移動速度
	shotr=shotr-(shotr>0) ;発射レート

	if (ml=1)&(shotr=0){ ;left click
	  bulx=-dx*shots : bulz=-dz*shots : buly=-dy*shots
		shotr=5  ;: dmmplay 4;大麻ー加算
			regobj obsh,mdsh,OBJ_MOVE|OBJ_XFRONT
			setcoli obsh,2
			selpos obsh : objsetf3 wpx,wpy,wpz ;弾初期位置
			seldir obsh : objsetf3 bulx,buly,bulz ;移動量
	}

	;obshの上限が512なのでそれを超えないように減算する
	if obsh>300{
		obsh=obsh-10
		}
;--------------撃終了

;--------------被弾処理

repeat enemx
	c=cnt
	if enhp(c)>0{
	getcoli o,oben(c),15.0 ;oに当たったショットのobjctIDが代入される
	if o>-1  : gosub *enhit ;当たってたら処理にすすむ
}
loop

	hgdraw

	fprt "Remaining enemy: "+encnt,8,8
	
	hgsync 13

	if esc!1 : goto *main : else : end




;-------------------------------------------------------------------------------------------------------------------------------サブルーチン
*enhit
	dmmplay 5  : enhp(c)=enhp(c)-10 : delobj o
	;setscale obhp(c),enhp(c)/enhp,1.0,1.0
    ;ishit=1
if enhp(c)<1{
	dmmplay 3 : delobj oben(c) 
	encnt=encnt-1
}
 
return

*viewp
	;---------------マウスによる視点移動量計算
    winlx=ginfo(4) : winly=ginfo(5)
	winrealw=ginfo(12) : winactw=ginfo(10) : winrealh=ginfo(11) : winacth=ginfo(13)
	
	zurer=(winactw-winrealw)/2
	zuretop=(winrealh-winacth)-zurer ;上下方向のずれ=外枠の厚さ+トップのタイトル部の厚さ

	centerx=winlx+zurer+(winactw/2)
	centery=winly+zuretop+(winacth/2)
	
	x=mousex : z=mousey
	;mx=ginfo_mx  ;640x480のとき x=323,mx=352→mousex,yのほうが正しい
	
	mdx=winactw/2-x : mdz=winacth/2-z
	
	mouse centerx,centery,-1
;---------------
	
;---------------視点処理
	selcang : objgetfv an
	;キーによる視点移動
	;if r=1 : an(2)-=angles
	;if l=1 : an(2)+=angles

	;マウスによる視点移動
	an(1)+=sens*mdx

	;縦方向の視点移動は制限
	if an(0)<M_pi/2 && an(0)>-(M_pi/2) { 
		an(0)+=sens*mdz ;pi/2~-pi/2のときのみ視点移動量加算
		}else{
			if an(0)>=M_pi/2 : an(0)-=0.1 ;もし超えてたら加算減算して元に戻す
			if an(0)<=-(M_pi/2) : an(0)+=0.1
		}
	
	objsetfv an
;---------------視点終了
return


/**big
	dmmplay 6
	regobj boss,mden
	setscale boss,50.0,50.0,50.0
	selpos boss : objset3 0,-10,0
	return*/
	
*wallhit

sdim a,1122	
bload "map2.txt",a　;マップデータ読み込み
notesel a ;デフォ作業

	px=po(0)+mapw/2 : py=po(1) :pz=po(2)+maph/2 ;プレイヤー座標をマップ上相対位置に直す
	rx=int(px/boxsize) : rz=int(pz/boxsize) ;壁サイズで割る
	canmove=1
	cansmove=1

noteget gyou,rz
 s=strmid(gyou,rx,1)

switch s 
case 0
canmove=1
swbreak
case 1
canmove=0
swbreak
default
canmove=0
swbreak
swend

	if canmove!0{
	selcpos : objsetfv po ;壁がなければカメラ座標を設定
	selpos oplayer : objsetfv po ;当たり判定用箱描画
	;selposobjsetfv po , selcpos objsetf3 
} 

/*switch ss
case 0
cansmove=1
swbreak
case 1
cansmove=0
swbreak
default
canmove=0
swbreak
swend

if cansmove!0{
	delobj obsh
}*/
return

*plmove
	if po(1)<grlvl{
		po(1)+=1.0
		}
		
		ifdbl=0
		if (w=1&a=1) or (w=1&d=1) or (s=1&a=1) or (s=1&d=1){ ;同時推し判定
			ifdbl=1
		}
	
	
		if w=1{
			po(0)-=dx*movef
			po(2)-=dz*movef
			;step音再生
			stepc+=1
			if stepc>steprf{
				dmmplay 0
				stepc=0
			}
		}
	
		if a=1{
			po(0)-=dz*movesi
			po(2)+=dx*movesi
			if ifdbl!1{ ;同時推し時はサイド音を再生しない(変な音声になるので)
			;step音を再生
			stepc+=1
			if stepc>steprsi{
				dmmplay 1
				stepc=0
			}
		}
		}
	
		if s=1{
			po(0)+=dx*moveb
			po(2)+=dz*moveb
			;step音を再生
			stepc+=1
			if stepc>steprb{
				dmmplay 1
				stepc=0
			}
		}
	
		if d=1{
			po(0)+=dz*movesi
			po(2)-=dx*movesi
			if ifdbl!1{
			;step音を再生
			stepc+=1
			if stepc>steprsi{
				dmmplay 1
				stepc=0
			}
		}
		}

		;ジャンプ処理
		if space=1{
			if po(1)>=grlvl{
			po(1)=po(1)-jumph
			}
		}
		return